default_platform(:ios)

platform :ios do
  # Helper to determine if running in CI
  def is_ci
    ENV['CI'] == 'true' || ENV['GITHUB_ACTIONS'] == 'true'
  end

  desc "Build and upload to TestFlight"
  lane :beta do
    # Ensure tools present
    setup_ci if is_ci

    # Optionally install pods (Flutter will also trigger as needed)
    cocoapods(clean_install: true) unless is_ci

    # Build numbers and version
    build_number = ENV["GITHUB_RUN_NUMBER"] || ENV["BUILD_NUMBER"] || Time.now.strftime("%Y%m%d%H%M")
    app_version = ENV["APP_VERSION"] || get_version_number(xcodeproj: "Runner.xcodeproj")

    # Handle code signing based on available configuration
    if ENV["MATCH_PASSWORD"] && (ENV["MATCH_SSH_KEY"] || ENV["MATCH_GIT_BASIC_AUTHORIZATION"])
      # Use match for code signing (preferred method)
      UI.message("üì± Using fastlane match for code signing...")
      
      # Set up API key for match to avoid 2FA
      api_key = nil
      if ENV["APPLE_API_KEY_ID"] && ENV["APPLE_API_ISSUER_ID"] && ENV["APPLE_API_PRIVATE_KEY"]
        api_key = app_store_connect_api_key(
          key_id: ENV["APPLE_API_KEY_ID"],
          issuer_id: ENV["APPLE_API_ISSUER_ID"],
          key_content: ENV["APPLE_API_PRIVATE_KEY"],
          is_key_content_base64: true
        )
      end
      
      match_params = {
        type: "appstore",
        readonly: is_ci,  # Use readonly mode in CI to avoid creation issues
        verbose: true,
        api_key: api_key
      }
      
      # Add authentication method - prefer HTTPS over SSH for reliability
      if ENV["MATCH_GIT_BASIC_AUTHORIZATION"]
        # Handle both raw GitHub tokens and pre-encoded base64 strings
        auth_token = ENV["MATCH_GIT_BASIC_AUTHORIZATION"]
        if auth_token.start_with?("ghp_") || auth_token.start_with?("github_pat_")
          # Convert raw GitHub token to base64 format
          require 'base64'
          encoded_auth = Base64.strict_encode64("token:#{auth_token}")
          match_params[:git_basic_authorization] = encoded_auth
          UI.message("üîë Using GitHub token authentication")
        else
          # Assume it's already base64 encoded
          match_params[:git_basic_authorization] = auth_token
          UI.message("üîë Using base64 encoded authentication")
        end
      elsif ENV["MATCH_SSH_KEY"]
        # Use SSH key file path instead of raw key content
        match_params[:git_private_key] = "~/.ssh/id_ed25519"
        UI.message("üîë Using SSH key authentication")
      end
      
      # Only force creation if not in CI and we have proper authentication
      if !is_ci && ENV["MATCH_GIT_BASIC_AUTHORIZATION"]
        match_params[:force] = true
      end
      
      match(match_params)
      
      # Build IPA using Flutter with code signing from match
      # Get the certificate name and provisioning profile from match environment variables
      certificate_name = ENV["sigh_com.biso.no_appstore_certificate-name"]
      provisioning_profile = ENV["sigh_com.biso.no_appstore_profile-name"]
      team_id = ENV["sigh_com.biso.no_appstore_team-id"]
      
      UI.message("Using certificate: #{certificate_name}")
      UI.message("Using provisioning profile: #{provisioning_profile}")
      UI.message("Using team ID: #{team_id}")
      
      # Update Xcode project to use automatic signing with the team ID
      update_code_signing_settings(
        use_automatic_signing: true,
        team_id: team_id,
        targets: ["Runner"],  # Your main app target
        code_sign_identity: "Apple Distribution",  # Use distribution identity for app store
        profile_name: provisioning_profile
      )
      
      # Build with explicit code signing
      sh "cd ../.. && flutter build ipa --release --build-name=#{app_version} --build-number=#{build_number} --export-method=app-store"
      
    else
      # Fallback to manual signing (existing approach)
      UI.message("üì± Using manual code signing configuration...")
      
      # Create ExportOptions.plist for flutter build ipa
      export_plist_path = File.join(Dir.mktmpdir, "ExportOptions.plist")
      provisioning_profile_name = ENV["PROVISIONING_PROFILE_NAME"] || ENV["PROVISIONING_PROFILE_SPECIFIER"]
      
      File.write(export_plist_path, <<~PLIST)
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
          <key>method</key>
          <string>app-store</string>
          <key>signingStyle</key>
          <string>manual</string>
          <key>provisioningProfiles</key>
          <dict>
            <key>com.biso.no</key>
            <string>#{provisioning_profile_name}</string>
          </dict>
          <key>destination</key>
          <string>export</string>
          <key>uploadBitcode</key>
          <false/>
          <key>uploadSymbols</key>
          <true/>
          <key>compileBitcode</key>
          <false/>
          <key>stripSwiftSymbols</key>
          <true/>
        </dict>
        </plist>
      PLIST

      # Build IPA using Flutter with manual signing
      sh "cd ../.. && flutter build ipa --release --build-name=#{app_version} --build-number=#{build_number} --export-options-plist=#{export_plist_path}"
    end

    # Find produced IPA
    ipa_path = Dir[File.expand_path("../../build/ios/ipa/*.ipa", __dir__)].first
    UI.user_error!("No IPA file found!") unless ipa_path
    UI.success("‚úÖ Found IPA: #{ipa_path}")

    # Upload to TestFlight using App Store Connect API key if provided
    if (ENV["APPLE_API_KEY_ID"] || ENV["APP_STORE_CONNECT_API_KEY_ID"]) && 
       (ENV["APPLE_API_ISSUER_ID"] || ENV["APP_STORE_CONNECT_API_ISSUER_ID"]) && 
       (ENV["APPLE_API_PRIVATE_KEY"] || ENV["APP_STORE_CONNECT_API_KEY"])
      
      # Support both naming conventions
      key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"] || ENV["APPLE_API_KEY_ID"]
      issuer_id = ENV["APP_STORE_CONNECT_API_ISSUER_ID"] || ENV["APPLE_API_ISSUER_ID"]
      key_content = ENV["APP_STORE_CONNECT_API_KEY"] || ENV["APPLE_API_PRIVATE_KEY"]
      is_base64 = ENV["APP_STORE_CONNECT_API_KEY"] ? true : false
      
      UI.message("üîë Using App Store Connect API for authentication...")
      
      api_key = app_store_connect_api_key(
        key_id: key_id,
        issuer_id: issuer_id,
        key_content: key_content,
        is_key_content_base64: is_base64
      )
      
      pilot(
        api_key: api_key,
        skip_waiting_for_build_processing: true,
        ipa: ipa_path,
        changelog: "Build #{build_number} from GitHub Actions",
        distribute_external: false,
        notify_external_testers: false
      )
    else
      # Fallback to Apple ID auth (not recommended for CI)
      UI.important("‚ö†Ô∏è Using Apple ID authentication (may require 2FA)...")
      pilot(
        skip_waiting_for_build_processing: true,
        ipa: ipa_path
      )
    end
    
    UI.success("üéâ Successfully uploaded to TestFlight!")
  end

  desc "Build and release to App Store"
  lane :release do
    # Ensure we're not accidentally releasing from CI without explicit permission
    if is_ci && !ENV["ALLOW_RELEASE_FROM_CI"]
      UI.user_error!("Release from CI requires ALLOW_RELEASE_FROM_CI=true")
    end

    setup_ci if is_ci

    # Use match for production release
    if ENV["MATCH_PASSWORD"] && (ENV["MATCH_SSH_KEY"] || ENV["MATCH_GIT_BASIC_AUTHORIZATION"])
      # Set up API key for match to avoid 2FA
      api_key = nil
      if ENV["APPLE_API_KEY_ID"] && ENV["APPLE_API_ISSUER_ID"] && ENV["APPLE_API_PRIVATE_KEY"]
        api_key = app_store_connect_api_key(
          key_id: ENV["APPLE_API_KEY_ID"],
          issuer_id: ENV["APPLE_API_ISSUER_ID"],
          key_content: ENV["APPLE_API_PRIVATE_KEY"],
          is_key_content_base64: true
        )
      end
      
      match_params = {
        type: "appstore",
        readonly: is_ci,
        api_key: api_key
      }
      
      # Add authentication method
      if ENV["MATCH_GIT_BASIC_AUTHORIZATION"]
        # Handle both raw GitHub tokens and pre-encoded base64 strings
        auth_token = ENV["MATCH_GIT_BASIC_AUTHORIZATION"]
        if auth_token.start_with?("ghp_") || auth_token.start_with?("github_pat_")
          # Convert raw GitHub token to base64 format
          require 'base64'
          encoded_auth = Base64.strict_encode64("token:#{auth_token}")
          match_params[:git_basic_authorization] = encoded_auth
          UI.message("üîë Using GitHub token authentication")
        else
          # Assume it's already base64 encoded
          match_params[:git_basic_authorization] = auth_token
          UI.message("üîë Using base64 encoded authentication")
        end
      elsif ENV["MATCH_SSH_KEY"]
        match_params[:git_private_key] = "~/.ssh/id_ed25519"
        UI.message("üîë Using SSH key authentication")
      end
      
      match(match_params)
    end

    # Get the latest build number from TestFlight
    # Reuse api_key from match setup above, or create new one if match wasn't used
    if api_key.nil? && ENV["APP_STORE_CONNECT_API_KEY_ID"]
      api_key = app_store_connect_api_key(
        key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
        issuer_id: ENV["APP_STORE_CONNECT_API_ISSUER_ID"],
        key_content: ENV["APP_STORE_CONNECT_API_KEY"],
        is_key_content_base64: true
      )
    end

    build_number = ENV["GITHUB_RUN_NUMBER"] || (latest_testflight_build_number(api_key: api_key) + 1)
    app_version = get_version_number(xcodeproj: "Runner.xcodeproj")

    # Build the app
    sh "cd ../.. && flutter build ipa --release --build-name=#{app_version} --build-number=#{build_number}"

    ipa_path = Dir[File.expand_path("../../build/ios/ipa/*.ipa", __dir__)].first
    UI.user_error!("No IPA file found!") unless ipa_path

    # Upload to App Store
    upload_to_app_store(
      api_key: api_key,
      force: true,
      skip_screenshots: true,
      skip_metadata: false,
      ipa: ipa_path,
      precheck_include_in_app_purchases: false,
      submission_information: {
        add_id_info_uses_idfa: false,
        add_id_info_serves_ads: false,
        add_id_info_tracks_action: false,
        add_id_info_tracks_install: false,
        add_id_info_limits_tracking: true
      }
    )
    
    UI.success("üéâ Successfully submitted to App Store!")
  end

  desc "Sync certificates and profiles"
  lane :sync_certificates do
    UI.user_error!("Match not configured") unless ENV["MATCH_PASSWORD"]
    
    match(type: "development", force_for_new_devices: true)
    match(type: "appstore")
    match(type: "adhoc") if ENV["SYNC_ADHOC"]
    
    UI.success("‚úÖ Certificates synced successfully!")
  end

  desc "Setup match for the first time"
  lane :setup_match do
    UI.header("Setting up fastlane match")
    
    # Set up API key to avoid 2FA
    api_key = nil
    if ENV["APPLE_API_KEY_ID"] && ENV["APPLE_API_ISSUER_ID"] && ENV["APPLE_API_PRIVATE_KEY"]
      api_key = app_store_connect_api_key(
        key_id: ENV["APPLE_API_KEY_ID"],
        issuer_id: ENV["APPLE_API_ISSUER_ID"],
        key_content: ENV["APPLE_API_PRIVATE_KEY"],
        is_key_content_base64: true
      )
      UI.success("üîë Using App Store Connect API key for authentication")
    else
      UI.error("‚ùå API key environment variables not set")
      UI.important("Set: APPLE_API_KEY_ID, APPLE_API_ISSUER_ID, APPLE_API_PRIVATE_KEY")
      exit 1
    end
    
    # Generate certificates and profiles with API key
    UI.message("Generating App Store certificates and profiles...")
    
    # Set up authentication parameters - COMPLETELY bypass Matchfile for certificate generation
    match_params = {
      type: "appstore",
      app_identifier: ["com.biso.no"],
      git_url: "https://github.com/biso-no/ios-certificates",
      storage_mode: "git",
      git_branch: "main", 
      shallow_clone: true,
      force: true,
      readonly: false,  # CRITICAL: Must be false to generate certificates
      skip_confirmation: true,
      api_key: api_key
    }
    
    # Add GitHub authentication if available
    if ENV["MATCH_GIT_BASIC_AUTHORIZATION"]
      # Handle both raw GitHub tokens and pre-encoded base64 strings
      auth_token = ENV["MATCH_GIT_BASIC_AUTHORIZATION"]
      if auth_token.start_with?("ghp_") || auth_token.start_with?("github_pat_")
        # Convert raw GitHub token to base64 format
        require 'base64'
        encoded_auth = Base64.strict_encode64("token:#{auth_token}")
        match_params[:git_basic_authorization] = encoded_auth
        UI.message("üîë Using GitHub token authentication")
      else
        # Assume it's already base64 encoded
        match_params[:git_basic_authorization] = auth_token
        UI.message("üîë Using base64 encoded authentication")
      end
    end
    
    match(match_params)
    
    UI.message("Generating Development certificates and profiles...")
    match_params[:type] = "development"
    match(match_params)
    
    UI.success("‚úÖ Match setup complete!")
    UI.important("Now you can run: bundle exec fastlane beta")
  end

  desc "Validate configuration"
  lane :validate do
    UI.header("Validating iOS deployment configuration")
    
    # Check for required environment variables
    required_for_api = [
      "APP_STORE_CONNECT_API_KEY_ID",
      "APP_STORE_CONNECT_API_ISSUER_ID", 
      "APP_STORE_CONNECT_API_KEY"
    ]
    
    required_for_match = [
      "MATCH_PASSWORD"
    ]
    
    has_api = required_for_api.all? { |key| ENV[key] || ENV[key.gsub("APP_STORE_CONNECT", "APPLE")] }
    has_match = required_for_match.all? { |key| ENV[key] }
    
    if has_api
      UI.success("‚úÖ App Store Connect API configured")
    else
      UI.error("‚ùå App Store Connect API not configured")
      UI.important("Missing: #{required_for_api.reject { |k| ENV[k] }.join(', ')}")
    end
    
    if has_match
      UI.success("‚úÖ Match configured")
      
      # Test match access
      begin
        match(type: "appstore", readonly: true)
        UI.success("‚úÖ Match certificates accessible")
      rescue => e
        UI.error("‚ùå Match certificates not accessible: #{e.message}")
      end
    else
      UI.error("‚ùå Match not configured")
    end
    
    # Check Flutter
    sh("flutter doctor -v") rescue UI.error("Flutter not installed")
    
    # Check CocoaPods
    cocoapods(repo_update: false, deployment: false) rescue UI.error("CocoaPods issue detected")
    
    UI.success("üéâ Validation complete!")
  end

  desc "Clean build artifacts"
  lane :clean do
    UI.message("üßπ Cleaning build artifacts...")
    
    sh "cd ../.. && flutter clean"
    sh "rm -rf ~/Library/Developer/Xcode/DerivedData/*"
    sh "rm -rf build/"
    
    UI.success("‚úÖ Clean complete!")
  end

  # Error handling
  error do |lane, exception|
    UI.error("‚ùå Error in lane #{lane}: #{exception.message}")
    
    # Clean up any temporary files
    sh "rm -rf /tmp/ExportOptions*.plist" rescue nil
    
    # Send notification if configured
    if ENV["SLACK_URL"]
      slack(
        message: "iOS deployment failed in lane #{lane}",
        success: false,
        slack_url: ENV["SLACK_URL"],
        attachment_properties: {
          fields: [
            { title: "Error", value: exception.message, short: false },
            { title: "Build Number", value: ENV["GITHUB_RUN_NUMBER"] || "N/A", short: true }
          ]
        }
      )
    end
  end
end